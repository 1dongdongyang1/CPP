# 类与对象(上)

**文章目录**

1. [面向过程的面向对象的初步认识](#1.0)
2. [类的引入](#2.0)
3. [类的定义](#3.0)
4. [类的封装](#4.0)
5. [类的访问限定符](#5.0)
6. [类的实例化](#6.0)
7. [类对象模型](#7.0)
8. [this指针](#8.0)

---

## 1.面向过程的面向对象的初步认识	<p id="1.0"></p>

**C语言**是面向**过程**的，关注的是**过程**，分析出求解问题的步骤，通过函数调用逐步解决问题

**C++**是面向**对象**的，关注的是**对象**，将一件事情拆分成不同的对象，靠对象之间的交互完成

比如拿外卖进行举例

**C语言**关注过程：怎么点餐的，怎么接单的，怎么送餐的

**C++**关注对象：用户、商家、骑手三者，三者之间的交互

## 2.类的引入	<p id="2.0"></p>

**C语言**的结构体中只能定义**变量**，在**C++**结构体不仅可以定义**变量**，也可以定义**函数**

```cpp
struct C	//这里的C借指C语言
{
    int a;
    int* arr;
};

struct CPP	//这里的CPP借指C++
{
    int a;
    int Add(int a, int b)	//C++中结构体可以定义函数
    {
        return a+b;
    }
}
```

**C++**中，功能升级了的**结构体**，我们称为**类**，并引入新的关键字***class***

## 3.类的定义	<p id="3.0"></p>

> **声明**和**定义**的区别：
>
> **声明**是一种承诺，承诺要做什么但还没做
>
> **定义**是直接把这件事做了

```cpp
class Name
{
    //类体：成员函数+成员变量
};	//不要忘记分号
```

***class***为定义类的关键字，`Name`为**类的名字**，**{}**为**类的主体**，类定义结束时后面的**分号**不能省略

类体中内容称为**类的成员**：类中的**变量**称为**类的属性**或**成员变量**；类中的**函数**称为**类的方法**或**成员函数**

**类的的两种定义方法**：

1. **声明**和**定义**都放在类体中，注意：**成员函数**如果在类中**定义**，编译器可能会将其当成**内联函数**处理

   ```cpp
   class Person
   {
   public:
       //显示基本信息
       void ShowInfo()	//成员函数直接定义在类体中
       {
           cout<<_name<<"-"<<_sex<<"-"<<_age<<endl;
       }
   public:
       char* _name;	//声明
       char* _sex;
       int _age;
   };
   ```

2. 类**声明**放在`.h`文件中，成员函数**定义**放在`.cpp`文件中，注意：成员函数名前要加**类名::**

   >  **类定义了一个新的作用域**，类的所有成员都在类的作用域中。
   >
   > 在类外定义成员时，需要使用::作用域操作符指明成员属于哪个类域

   ```cpp
   //test.h
   class Person
   {
   public:
       void ShowInfo();	//声明
   public:
       char* _name;
       char* _sex;
       int _age;
   };
   
   //test.cpp
   #include<test.h>
   
   void Person::ShowInfo()
   {
       cout<<_name<<"-"<<_sex<<"-"<<_age<<endl;
   }
   ```

   工程中，更建议使用**第二种**

**成员变量命名规则的建议**：

建议在命名成员变量时，加前缀(如_)，这样可以对**成员变量**和**变量**进行区分

## 4.类的封装	<p id="4.0"></p>

面向对象的三大特征：**封装、继承、多态**

在**类和对象**阶段，主要是研究类的**封装**特性

**封装**：将**数据**和**操作数据的方法**进行有机结合，隐藏**对象的属性**和**实现细节**，仅对外公开接口和对象进行交互

**封装**本质上是一种**管理**，让用户更方便使用**类**

比如：

> 对于电脑这样复杂的设备，提供给用户的实际上只有开关机键和一些接口，让用户可以对电脑进行交互，但实际上电脑真正工作的却是CPU、显卡、内存等一些硬件元件
>
> 对于用户来说，并不需要知道电脑内部的硬件是如何工作的，只需要知道电脑如何开关机，如何链接键盘鼠标即可
>
> 所以，计算机厂商在计算机出厂时，在外部套上壳子，将内部的细节隐藏起来，仅仅对外提供开关机、相关接口，让用户可以与电脑交互即可

在C++中实现**封装**，可以通过**类**将**数据**和**操作数据的方法**进行有机结合，通过**访问权限**来**限制**对类内部实现的**访问**

## 5.类的限定访问符	<p id="5.0"></p>

C++通过***public、private、protected***三个关键字来控制**成员变量**和**成员函数**的**访问权限**，它们分别表示**公有的、私有的、受保护的**，被称为**成员限定访问符**

**说明**：

1. ***public***修饰的成员在类外可以**直接**被访问

   ***private***和***protected***修饰的成员在类外**不能直接**被访问(此处***private***和***protected***是类似的)

2. 访问权限的**作用域**从该访问限定符出现的位置开始，直到下一个访问限定符出现是为止

   如果后面没有访问限定符，**作用域**到`}`结束

3. ***class***的默认访问权限为***private***,***struct***的默认访问权限为***public***(因为***struct***要兼容C)
4. 访问限定符只有在**编译**时有用，当**数据映射到内存**后，没有任何访问限定符上的区别

> C++中***struct***和***class***的区别：
>
> 1.C++要兼容C语言，所以C++中***struct***可以当作**结构体**使用。
>
> 2.***struct***和***class***定义**类**是一样的，区别是***struct***定义的**类**默认权限是***public***,***class***定义的**类**默认权限是***private***。
>
> 3.二者在**继承**和**模板参数列表**也有区别

## 6.类的实例化	<p id="6.0"></p>

**定义**：用类类型创建**对象**的过程

> C语言中叫**变量**
>
> C++中叫**对象**

```cpp	
class Date	//Date是类名，不同于C语言的是，它可以直接使用
{
	int _a;  
};

int main()
{
    Date d1;	//类的实例化	类似：C语言创建结构体
    return 0;
}
```

1. **类是对对象进行描述的**，是一个**模板**一样的东西，限定了类有哪些成员，定义出一个类，**但并没有分配实际的内存空间**来储存它

   > 1. 内置对象：int/char/double
   >
   >    `int a;`
   >
   > 2. 自定义对象：类
   >
   >    `Date d1;`

2. 一个类可以实例化出多个对象，**实例化出的对象，占用实际的物理空间，储存类成员变量**

   > 例如可以定义多个整形，`int a;int b;`
   >
   > int是不占空间的，而a是占空间的
   >
   > 类和对象是同理

## 7.类对象模型	<p id="7.0"></p>

### 7.1类对象的大小

> 1. 类和对象的大小是一样的
> 2. 类似`int a;`，`sizeof(int)`与`sizeof(a)`是一样大的

```cpp
class A
{
public:
    void Print()
    {
        cout<<_a<<endl;
    }
private:
    int _a;
    char _b;
}

class B		//类中什么都没有，称为空类
{};

int main()
{
    A a;
    cout<<sizeof(a)<<endl;	//8	说明：只计算成员变量，没有算上成员函数
	cout<<sizeof(B)<<endl;	//1 	B是空类，规定空类的大小是1，1是用来占位的，不是用来存储数据
    return 0;
}
```

即：**对象**的大小是**成员变量**的大小，并且满足**结构体内存对齐规则**

> 结构体内存对齐规则：
>
> 1.  第一个成员在与结构体偏移量为0的地址处。
> 2.  其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
>
> ​	注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。
>
> ​	VS中默认的对齐数为8
>
> 3. 结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。
>
> 4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

**类的成员**包含**成员变量**和**成员函数**，那么一个类的对象中包含了什么？

 ### 7.2类对象的储存方式的猜测（一个类的对象中包含了什么）

* 对象中包含类的各个成员

  > **缺陷**：
  >
  > 每个对象中的成员变量是不同的，但是会调用相同的成员函数。
  >
  > 如果按照上述方式存储，当一个类创建多个对象时，每个对象都会保存一份代码，相同的代码保存多次，浪费空间

* 代码只保存一份，在对象中保存成员变量和函数指针

  > 如果按照上述方式存储，通过`sizeof`计算的对象的大小不匹配，缺少函数指针的大小

* 对象中保存成员变量，成员函数存放在公共的代码段

  > 只有按照上述方式存储，通过`sizeof`计算的对象的大小才能匹配

**结论**：对象中保存成员变量，成员函数存放在公共的代码段

## 8.this指针	<p id="8.0"></p>

### 8.1this指针的引入

我们先来定义一个日期类`Date`

```cpp
class Date
{
public:
    void Init(int year, int month, int day)
    {
        _year=year;
        _month=month;
        _day=day;
    }
    
    void Print()
    {
        cout <<_year<< "-" <<_month << "-"<< _day <<endl;
    }
private:
    int _year;
    int _month;
    int _day;
};

int main()
{
    Date d1;
    Date d2;
    
    d1.Init(2024,5,20);
    d2.Init(0,1,1);
    d1.Print();
    d2.Print();
    return 0;
}
```

对于上述类，有这样一个问题

Date类中有 Init 与 Print 两个成员函数，函数体中没有关于不同对象的区分，那当d1调用 Init 函

数时，该函数是如何知道应该设置d1对象，而不是设置d2对象呢？

C++通过引入***this***指针解决当前问题，即：

> **C++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有“成员变量”的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成**。

```cpp
int main()
{
    Date d1;
    Date d2;
    					//编译器添加后
    d1.Init(2024,5,20);	//d1.Init(&d1,2024,5,20);
    d2.Init(0,1,1);		//d2.Init(&d2,0,1,1);
    d1.Print();			//d1.Print(&d1);
    d2.Print();			//d2.Print(&d2);
    return 0;
}
```

### 8.2this指针的特性

1. ***this***指针的**类型**：**类类型* ** **const**  ，即成员函数中，不能给***this***指针赋值
2. 只能在**成员函数**的内部使用
3. ***this***指针的本质上是**成员函数**的**形参**，当对象调用成员函数时，将对象地址作为实参传递给***this***形参，所以对象中**不存储this**指针
4. ***this***指针时**成员函数**第一个隐含的**指针形参**，一般情况有**编译器**通过**ecx寄存器**自动传递，不需要用户传递

```cpp
class Date
{
public:
    void Init(int year, int month, int day)
    {
        _year=year;
        _month=month;
        _day=day;
    }
    
    void Print()
    {
        cout <<_year<< "-" <<_month << "-"<< _day <<endl;
    }
private:
    int _year;
    int _month;
    int _day;
};

//函数调用经编译器处理后
class Date
{
public:
    void Init(Date* this,int year, int month, int day)	//this用于演示，这里出现this会报错
    {
        this->_year=year;		//这里写this不会报错
        this->_month=month;
        this->_day=day;
    }
    
    void Print(Date* this)
    {
        cout <<this->_year<< "-" <<this->_month << "-"<<this->_day<<endl;
    }
private:
    int _year;
    int _month;
    int _day;
};
```

