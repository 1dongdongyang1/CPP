# C++模板初阶

**文章目录**：

1. [模板的引入](#1.0)
2. [函数模板](#2.0)
   1. [概念](#2.1)
   2. [原理](#2.2)
   3. [实例化](#2.3)
   4. [匹配原则](#2.4)
3. [类模板](#3.0)
   1. [定义格式](#3.1)
   2. [实例化](#3.2)
4. [结尾](#4.0)

---

## 1.模板的引入<p id="1.0"></p>

> C++在C的基础上引入了类和对象

```cpp
//如何实现一个通用的交换函数？
//答：函数重载
void Swap(int& a, int& b)
{
    int tem = a;
    a = b;
    b = tem;
}

void Swap(char& a, char& b)
{
    char tem = a;
    a = b;
    b = tem;
}

void Swap(double& a, double& b)
{
    double tem = a;
    a = b;
    b = tem;
}

//...
```

**函数重载**可以实现，但还是有缺点：

1. 函数重载仅仅是类型不同，代码**复用度**比较低，而且需要新的类型交换时，又需要自己**手动添加**
2. 代码**可维护性**低，一个出错可能导致所有的重载均出错

因此，C++引入了**模板**，我们只需要写一个模板，后续不同的类型**编译器**就自动帮我们实现函数

> **模板**是泛型编程的基础
>
> **泛型编程**：编写与类型无关的通用代码，是代码复用的一种手段

**模板**分为：**函数模板**和**类模板**

## 2.函数模板<p id="2.0"></p>

```cpp
//让我们用函数模板的方式再来实现一个通用的交换函数
template<typename T>
void Swap(T& a, T& b)
{
    T tem = a;
    a = b;
    b = tem;
}
//我们只需要实现一个模板，编译器会根据传入参数的类型自动生成对应类型的函数，继而调用函数
```

### 2.1概念<p id="2.1"></p>

**概念**：**函数模板**代表了一个函数家族，该函数模板与类型**无关**，在使用时被实例化，根据实参类型产生函数的特定类型版本

**格式**：

```cpp
template<typename T1, typename T2,..., typename Tn>
返回值类型 函数模板名(参数列表)
{}
```

1. ***template***是定义模板的关键字
2. ***typename***是定义模板参数的关键字，可以用***class***替换(这里不能用***struct***代替***class***)
3. 简单理解模板的格式：定义模板参数+类型为模板参数的函数

### 2.2原理<p id="2.2"></p>

> 函数模板是图纸，它本身并不是函数，是编译器用使用方式产生特定具体类型函数的模具
>
> 其实模板就是将本来应该是我们做的**重复**的事情交给了编译器

模板的使用发生在编译器**编译**阶段，编译器根据传入的实参类型**推演**生成对应类型的函数，以供调用

1. 编译器不编译模板，编译的是根据传入的实参类型结合模板推演出的函数
2. 如果没有用到函数模板，只要函数模板的格式是对的，不管是什么内容都能编译通过，因为编译器没有使用模板

```cpp
template<typename T>
void Swap(T& a, T& b)
{
    T tem = a;
    a = b;
    b = tem;
}

int main()
{
    int a = 1, b = 0;	//当int类型使用函数模板时，编译器通过对实参类型的推演，将T确定为int类型，
    Swap(a,b);			//然后产生一份专门处理int类型的代码
    
    double c = 1.0, d = 0.0;
    Swap(c,d);			//double类型也是同理
    return 0;
}
```

### 2.3实例化<p id="2.3"></p>

用不同类型的参数使用函数模板时，称为函数模板的**实例化**，分为：**隐式实例化**和**显式实例化**

1. **隐式实例化**：编译器自己推演的

   ```cpp
   template<class T>
   T Add(const T& a, const T& b)
   {
       return a+b;
   }
   
   int main()
   {
       int a1=1,a2=2;
       double d1=1.1,d2=2.2;
       Add(a1,a2);	//正常情况
       Add(d1,d2);
       
       Add(a1,d1);	//该语句不能通过编译
       			//因为在编译期间，当编译器看到该实例化时，需要推演其实参的类型
       			//通过实参a1将T推演成int,通过实参d1将T推演成double,但模板类型只有一个T
       			//编译器会因为无法判断将T确定为int/double而报错
       			//在模板中，编译器一般不会进行类型转换操作，因为一旦转换出现问题，编译器就需要背黑锅
       //此时有两种处理方法：1.用户自己来强转 2.使用显式实例化
       Add(a1,(int)d1);	//自己强转
       return 0;
   }
   ```

2. **显式实例化**：用户指定的，在函数名后跟<>，在<>中指定模板参数的实际类型

   ```cpp
   int main()
   {
       int a = 1;
       double d = 1.1;
       Add<int>(a,d);
       return 0;
   }
   ```

   如果类型不匹配，编译器会尝试进行**隐式类型转换**，如果无法成功转换，编译器将报错

### 2.4匹配原则<p id="2.4"></p>

1. 非模板函数可以和同名模板同时存在，即使这个非模板函数可以被模板实例化出来

   ```CPP
   //比如下面的情况
   //专门处理int的加法函数
   int Add(int a, int b)
   {
       return a+b;
   }
   
   //加法模板
   template<class T>
   T Add(T a, T b)
   {
       return a+b;
   }
   //这两者可以同时存在
   ```

2. 对于其他条件完全相同的非模板函数和模板，会优先调用非模板函数

   ```cpp
   int main()
   {
       Add(1,2);		//会调用现成的函数
       Add<int>(1,2);	//显式实例化，使用模板
       
       
       return 0;
   }
   ```

3. 如果模板可以实例化出一个具有更好匹配的函数，那么会选择模板

   ```cpp
   int Add(int a, int b)
   {
       return a+b;
   }
   
   template<class T1, class T2>
   T1 Add(T1 a, T2 b)
   {
       return a+b;
   }
   
   int main()
   {
       Add(1,2);	//与非模板函数类型完全一致，直接调用该函数
       Add(1,2.1);	//函数模板可以生成更加匹配的版本，编译器就会实例化出该函数
       return 0;
   }
   ```

## 3.类模板<p id="3.0"></p>

> 因为都是模板，所以类模板与函数模板的性质基本上是一样的

### 3.1定义格式<p id="3.1"></p>

```cpp
template<class T>	//class/typename都可以，class写起来更快一点
class 类模板名
{
    //类成员定义
}
```

```cpp
//实现动态顺序表模板
template<class T>
class vector
{
public:
	vector()
		:_a(nullptr)
		,_size(0)
		,_capacity(0)
	{}

	~vector();	//这里用析构函数演示：在类中声明，在类外定义
	
	void push_back(const T& x)
	{
		if (_size == _capacity)
		{
			size_t newcapacity = _capacity == 0 ? 2 : _capacity * 2;
			T* tem = new T[newcapacity];
			if (_a)
			{
				memcpy(tem, _a, sizeof(T) * _size);
				delete[] _a;
			}
			_a = tem;
			_capacity = newcapacity;
		}
		_a[_size] = x;
		++_size;
	}
private:
	T* _a;
	size_t _size;
	size_t _capacity;
};

//类模板中函数在类外定义时，需加模板参数列表
template<class T>
vector<T>::~vector()
{
    delete[] _a;
    _a = nullptr;
    _size = _capacity = 0;
}
```

### 3.2实例化<p id="3.2"></p>

> 类模板在实例化上与函数模板不同，它只能显式定义

类模板实例化需要在类模板名字后跟<>，然后在<>中放实例化的类型

```cpp
//在正常的类中，类名就是类型
//而在类模板中，
//vector是类名，vector<int>才是类型
vector<int> v1;
vector<double> v2;
```

## 4.结尾<p id="4.0"></p>

> 进入C++到现在学习了以下语法：
>
> 基础语法(如：函数重载) + 类和对象(4个重要默认成员函数 + 运算符重载) + 泛型编程：模板
>
> 解决一些C语言解决的不好或没有解决的问题

1. 忘记初始化和销毁                                                                          ------------>构造+析构
2. 没有封装，谁都可以修改结构体数据					   ------------>类+访问限定符
3. 如果想同时定义两个栈，一个存int，一个存double，做不到   ------------>模板
